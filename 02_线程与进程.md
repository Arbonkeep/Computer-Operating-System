# 线程与进程

    1.进程的定义，组成，组织与特征
        1. 进程的定义
            * 程序：就是一个指令序列
                * 单道程序：内存中只有一道程序
                * 多道程序：内存中同时存入多道程序
                    * 为了方便操作系统管理，完成各程序并发执行，引入进程，进程实体概念。
                    * 系统为每个程序配置一个数据结构，称为进程控制块(PCB)，用来描述进程的各种信息（如程序代码放置的位置）
                    
            * 定义：进程实体（进程映像）由PCB，程序段，数据段三部分组成。一般情况下，我们把进程实体就简称为进程。例如：所谓
                    创建进程，实质上是创建进程实体中的PCB，而撤销进程，实质上是撤销进程实体中的PCB
                    
                    * 注意：PCB是进程存在的唯一标志
                    * 三种进程的定义：（都在强调动态性）
                        1. 进程是程序的一次执行过程
                        2. 进程是一个程序及其数据在处理机上顺序执行时所发生的活动
                        3. 进程是具有独立功能的程序在数据集合上运行的过程，它是系统进行资源分配和调度的一个独立单位
                    
                    总而言之，进程就是进程实体的运行过程，是系统进行资源分配和调度的一个独立单位。进程实体是静态的，进程是
                    动态的。

        2. 进程的组成（进程内部由什么构成）
            * 进程由程序段，数据段，进程控制块（PCB）组成
                * 程序段：存放程序代码
                * 数据段：存放程序运行过程中所需要的数据
                * 进程控制块（PCB）：操作系统通过PCB管理进程（存放着与进程管理的数据）
                    * PCB的第一种分类
                        1. 进程描述信息
                            * 进程标识符PID：当进程被创建时，操作系统会为进程分配一个唯一不重复的ID，用于区分不同的进程
                            * 用户标识符UID
                        2. 进程控制和管理信息
                            * 进程的当前状态
                            * 进程优先级
                        3. 资源分配清单
                            * 程序段指针
                            * 数据段指针
                            * 键盘
                            * 鼠标
                        4. 处理机相关信息
                            * 各种寄存器
                    * PCB的第二种分类
                        1. 进程标识符
                        2. 处理机状态
                        3. 进程调度信息
                        4. 进程控制信息

        3. 进程的组织（多个进程之间的组织方式）
            * 进程的组织方式
                1. 链接方式：按照进程状态将PCB分为多个队列，操作系统持有指向各个队列的指针
                    * 执行指针：指向当前处于运行状态的指针，单CPU中同一时刻只有一个执行进程
                    * 就绪队列指针：指向当前处于就绪状态的进程，会把优先级高的进程放在前面
                    * 阻塞队列指针：指向当前处于阻塞态的指针

                2. 索引方式：根据进程的状态不同，建立记几张索引表，操作系统持有指向各个索引表的指针
                    * 执行指针
                    * 就绪表指针
                    * 阻塞表指针
        
        4. 进程的特征
            * 动态性（最基本的特征）：进程是程序的一次执行过程，是动态的产生，变化和消亡的
            * 并发性：内存中有多个并发实体，各进程可以并发执行
            * 独立性：进程是能独立运行，独立获得资源，独立接受调度的基本单位
            * 异步性：各进程按各自独立，不可预知的速度向前推进，操作系统要提供“进程同步”来解决异步问题
            * 结构性：每个进程都会配置一个PCB。结构上看，进程由程序段，数据段，进程控制块（PCB）组成
        
            注意：进程是资源分配，接受调度的基本单位
    
    2. 进程的状态与转换
        1. 状态
            * 三种基本状态
                1. 运行状态（Running）：占有CPU，并在CPU上运行。注意：单核CPU在同一时刻只能有单个进程运行
                2. 就绪状态（Ready）：已经具备运行条件，但是没有空闲的CPU，不能运行。这个阶段除了没有处理机其余资源都
                                    具备
                3. 阻塞状态（Waiting/Blocked）：因等待某一事件而不能运行。如等待操作系统分配打印机
            * 另外的两种状态
                1. 创建状态（New）：进程正在被创建，操作系统正在为进程分配资源，初始化PCB
                2. 终止状态（Terminated）：进程正在从系统中撤销，操作系统会回收进程拥有的资源，撤销PCB
        
        2. 进程状态间的转换
            * 描述：
                刚开始进程处于创建态，完成一系列的工作后，进入就绪态（等待处理机），获得处理机后就进入运行态，当运行时，
                处理机（CPU）被调度给其他进程，该进程就会进入就绪状态，如果运行时的进程系统调用某些资源就会进入到阻塞态
                当阻塞态申请的资源被分配后，就会进入就绪态。

                注意：
                    * 运行态转换为阻塞态，是进程主动的，是因为该进程需要系统调用其他资源。而阻塞态转换为就绪态是被动的，
                      因为进程在被动等待资源分配到位。
                    * 不能由阻塞态直接转换为运行态，这是因为资源未被分配到位。也不能由就绪态直接转换为阻塞态。因为进入
                      阻塞态是进程主动请求的，必须在进程运行时，才能发出请求

    3. 进程控制
        1. 基本概念
            * 概念：进程控制就是对系统中的所有进程进行有效的管理，具有创建进程，撤销已有进程和实现进程之间转换的功能
                    也就是说，进程控制就是要实现进程间的转换

        2. 进程控制相关的原语
            * 特点：执行期间不允许中断，只能一气呵成
            * 注意：原语通过“关中断指令”和“开中断指令”来实现

            * 进程控制会导致进程状态的转换。原语必须做的三件事：
                1. 更新PCB中的信息
                    * 所有进程控制原语一定都会修改进程的状态标志
                    * 剥夺当前进程CPU的使用权，必然需要保存其运行环境
                    * 某进程在运行前必然要恢复其运行环境
                2. 将PCB插入合适的队列
                3. 分配/回收资源

            * 进程的创建
                1. 创建原语
                    * 申请空白PCB
                    * 为新进程分配所需要的资源
                    * 初始化PCB
                    * 将PCB插入就绪队列
                2. 引进进程创建的事件
                    * 用户登录：分时系统中，用户登录成功，系统会为其创建一个新的进程
                    * 作业调度：多道批处理系统中有新的作业放入内存时，会为其创建一个新的进程
                    * 提供服务：用户向操作系统提出某些请求时，会创建一个新的进程处理该请求
                    * 应用请求：由用户进程主动请求创建一个子进程
            
            * 进程的终止
                1. 撤销原语
                    * 从PCB中找到、终止进程的PCB
                    * 若进程正在运行，立刻剥夺CPU，将CPU分配给其他进程
                    * 终止所有子进程
                    * 将该进程所拥有的所有资源归还给父进程或者操作系统
                    * 删除PCB
                2. 引起进程终止的事件
                    * 正常结束
                    * 异常结束
                    * 外界干预

            * 进程的阻塞
                1. 阻塞原语
                    * 找到要阻塞的进程对应的PCB
                    * 保护进程运行现场，将PCB的状态信息设置为“阻塞态”，暂时停止进程运行
                    * 将PCB插入相应事件的等待队列
                2. 引起进程阻塞的事件
                    * 需要等待系统分配资源
                    * 需要等待相互合作的其他进程完成工作
        
            * 进程的唤醒
                1. 唤醒原语
                    * 在时间等待队列中找到PCB
                    * 将PCB等待队列移除，设置进程为就绪态
                    * 将PCB插入就绪队列，等待被调度
                2. 引起进程唤醒的事件
                    * 等待事件发生

            * 进程切换
                1. 切换原语
                    * 将运行环境信息存入PCB
                    * PCB移入相应的队列
                    * 选择另一个进程，并更新其PCB
                    * 根据PCB恢复新进程所需的运行环境
                2. 引起进程切换的事件
                    * 当前时间片到了
                    * 有更高优先级的进程到达
                    * 当前进程主动阻塞

    4. 进程通信
        1. 概述
            * 概念：就是指进程之间的信息交换
            * 注意：各进程之间的内存地址是相互独立的，就是说一个进程不能够访问另一个进程的内存地址空间
        
        2. 进程通信
            *　共享存储：两个进程对共享空间的访问必须是互斥的（互斥访问通过操作系统提供的工具实现。）
                1. 基于数据结构的共享
                    这种方式速度慢，限制多，是一种低级通信方式
                2. 基于存储区的共享
                    在相比之下，这种方式速度更快，是一种高级通信方式

            * 管道通信
                * 管道通信只能采用半双工通信，要向实现双向同时通信，需要设置两个管道
                * 各进程要互斥的访问管道，管道中只有存满数据才能写出数据
                * 如归没有写满数据，就不允许读数据，如果没有读完数据就不允许写数据
                * 数据一旦被读取就会从管道中抛弃，那么就是说读进程只能有一个

            * 消息传递：进程间的数据的交换以格式化消息为单位。进程通过操作系统提供的“发送/接收消息”两个原语
                       进行数据交换。传递结构化的消息（消息头，消息体）
                1. 直接通信方式
                    消息直接挂到接收进程消息缓冲队列上
                2. 间接通信方式
                    消息需要先发送到中间实体中（信箱）进程1使用发送原语发送，进程2通过接收原语接收

    4. 线程概念：多线程模型
        1.概述
            * 为什么要引入线程？
                因为有的进程可能需要“同时”做很多事情，而传统的进程只能够串行的执行一系列程序，所以引入了“线程”
            * 在引入线程之前，进程是最小执行单元，之后线程是最小执行单元
            * 概念：线程是一个基本的CPU执行单元，也是程序执行流的最小单位
            * 在引入线程之后，不仅线程能够并发，进程内的各线程也可以并发。在引入线程后，进程只作为除CPU之外的系
              统资源的分配单元
        
        2. 线程带来的变化
            * 资源分配、调度
                在传统进程机制中，进程是资源分配，调度的基本单位。引入线程后，进程是资源分配的基本单位，线程是
                调度的基本单位。
            * 并发性
                传统进程机制中，只能进程间实现并发，在引入线程后，各线程间也能够还是先并发，提高了并发度
            * 系统开销
                传统的进程间并发需要切换进程的运行环境，系统开销很大。线程间并发，如果是同一进程内线程切换则不需
                要进程切换，系统开销小。引入线程后，并发所带来的系统开销小

        3. 线程的属性
            * 线程是处理机调度的单位
            * 多CPU计算机中，各线程可占用不同的CPU
            * 每个线程都有一个线程ID、线程控制块(TCB)
            * 线程也有就绪，阻塞，运行三种基本状态
            * 线程几乎拥有系统资源
            * 同一进程的不同线程共享进程资源
            * 由于共享内存地址空间，同一进程中的线程通信甚至无需系统的干预
            * 同一进程间的线程切换不会引起进程切换，不同进程间的线程切换会引起进程的切换
            * 切换同进程内的线程，系统开销小

        4. 线程的实现方式
            * 用户级线程（User-Level Thread）
                它是由应用程序通过线程库实现的。所有的线程管理工作都由应用程序负责。用户级线程中，线程切换可以在
                用户态下完成，无需系统的干预。在用户看来是有多个线程的，但是在操作系统内核看来，并意识不到线程的
                存在（用户级线程对用户不透明，对操作系统透明）
                用户级线程就是“从用户视角看到能看到的线程”
            * 内核级线程（Kernrl-Level Thread）
                内核级线程的管理工作由操作系统内核完成，线程的调度，以及切换等工作都是内核负责，因此内核级线程的
                切换需要在核心态下完成
                内核级线程就是“从操作系统内核视角看能看到的线程”

            * 注意：操作系统只看得见内核级线程，因此只有内核级线程才是处理机分配的单位

            * 多线程模型：
                * 产生：在同时支持用户级线程与内核级线程的系统中，由几个用户级线程映射到几个内核级线程的问题引出

                * 分类：
                    1. 多对一模型：多个用户级线程映射到一个内核级线程，每个用户级线程只对应一个用户级线程
                        优点：用户级线程的切换在用户空间即可完成，不需要切换到核心态，线程管理的开销小，效率高
                        缺点：当一个用户级线程被阻塞后，整个进程都会被阻塞，并发度不高，多个线程不可在多核处理机
                              上运行
                    2. 一对一模型：一个用户级线程映射到一个内核级线程，每个用户进程有与用户级线程同数量的内核级线程
                        优点：当一个线程被阻塞后其他线程还能被执行，并发能力强，多线程可以在多核处理机上并行执行
                        缺点：一个用户级线程会占用多个内核几线程，线程切换由内核完成，需要切换到核心态，因此，线程
                              的管理成本高，开销大
                    3. 多对多线程：n个用户级线程映射到m个内核级线程，每个用户级线程对应一个内核级线程
                        优点：克服多对一模型并发度不高的缺点，又克服了一对一模型中一个用户级线程占用太多内核级线程
                             开销太大的缺点



































































    















































